:dup { 1 dupn } def
:dup2 { 2 dupn } def
:dup3 { 3 dupn } def
:dupb { b2a dup a2b } def
:dup2b { b2a dupb swap a2b } def
:pop { 1 popn } def
:pop2 { 2 popn } def
:pop3 { 3 popn } def
:popb { b2a pop } def
:pop2b { b2a popb a2b } def

:swap { 2 rotn } def
:rot { 3 rotn } def
:rot' { rot rot } def
:rotn { dup a2b dupn b2a 1+ popn } def

:{} { { } } def
:!! { ! ! } def
:| { ! swap ! * ! } def
:|| { {} swap if } def
:&& { {} if } def
:& { !! swap !! * } def
:if { rot ! 1+ popn call } def
:ifl { rot { pop } { pop2 } if } def
:_while_helper {
	dupb call
	{ b2a dupb swap a2b call _while_helper }
	{ popb popb } if
} def
:while { a2b a2b _while_helper } def

:$ { "$" } def

:≤ { dup2 dup2 < rot' = | } def
:≥ { dup2 dup2 > rot' = | } def
:≠ { = ! } def
:<=> { <=>* pop2 pop2 } def
:<=>* { dup2 dup2 < { -1 } { dup2 dup2 > 1 0 ifl } if } def

:le { dup2 dup2 lt rot' eq | } def
:ge { dup2 dup2 gt rot' eq | } def
:ne { eq ! } def
:cmp { cmp* pop2 pop2 } def
:cmp* { dup2 dup2 lt { -1 } { dup2 dup2 gt 1 0 ifl } if } def

:println { print "\n" print } def
:alias { fetch def } def
:abort { warn 1 quit } def

:1+ { 1 + } def
:1- { 1 - } def

:[] { 0 alloc } def
:get* { dup2 dup2 get } def
:apush { apush* pop } def

:__new_array_last_two { [] rot apush* swap apush* } def
:bind {
	a2b ( store the block )
	( get arguments )
	[] { swap dup "$" ne } { apush* } while pop

	( define new arguments and store previous value )
	[] swap 0
	{ dup2 len dup2 ≠ }
	{
		get*
		dup def? {
			dup dup fetch __new_array_last_two
			5 dupn swap apush
		} &&
		5 dupn defl
		4 popn
		1+
	} while
	pop

	( store the arguments and previous values, and call the block )
	swap b2a rot' a2b a2b call

	( undefine all argument functions )
	b2a 0
	{ dup2 len dup2 ≠ }
	{ get* undef 1+ } while
	pop pop

	( redefine all overwritten functions )
	b2a 0
	{ dup2 len dup2 ≠ }
	{ get* expand def 1+ } while
	pop pop
} def

:defb {
	1
	{ dup dupn "$" ne } { 1+ } while
	"bind" var swap wrapn def
} def


:rot* $ :a :b :c {
	b c a
} defb
